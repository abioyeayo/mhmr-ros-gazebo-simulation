Using Micro XRCE-DDS Agent instead of MAVROS to communicate with PX4 SITL in a ROS 2 environment requires a different approach since Micro XRCE-DDS is the middleware that allows communication with microcontrollers or resource-constrained environments directly via the DDS-XRCE protocol, which PX4 supports natively. Hereâ€™s a detailed guide to setting up the system and controlling PX4 SITL using Micro XRCE-DDS Agent in Gazebo Fortress.

### Overview of the Setup

1. **PX4 SITL**: Simulates the UAV running the PX4 firmware.
2. **Gazebo Fortress**: 3D simulation environment for visualizing and testing the UAV.
3. **Micro XRCE-DDS Agent**: Acts as a bridge between the PX4 firmware and ROS 2, using the DDS-XRCE protocol.
4. **ROS 2 Node**: A custom ROS 2 node will be used to send waypoint commands to PX4 through the XRCE-DDS bridge.

### Prerequisites

1. **ROS 2 Humble**: Make sure ROS 2 Humble is installed and set up correctly. Installation instructions can be found on the [ROS 2 Humble documentation](https://docs.ros.org/en/humble/Installation.html).
2. **PX4 Autopilot**: PX4 should be installed on your machine. Follow the [PX4 installation guide](https://docs.px4.io/main/en/dev_setup/dev_env_linux_ubuntu.html).
3. **Gazebo Fortress**: Gazebo Fortress should be installed on your system. Instructions can be found on the [Gazebo Fortress installation page](https://gazebosim.org/docs/fortress/install_ubuntu).
4. **Micro XRCE-DDS Agent**: Install Micro XRCE-DDS Agent, which enables DDS-XRCE communication between PX4 and your ROS 2 environment.

### Step 1: Install Micro XRCE-DDS Agent

To install Micro XRCE-DDS Agent, follow these steps:

1. Clone the Micro XRCE-DDS Agent repository:

    ```bash
    git clone https://github.com/eProsima/Micro-XRCE-DDS-Agent.git
    cd Micro-XRCE-DDS-Agent
    mkdir build && cd build
    cmake ..
    make
    sudo make install
    ```

2. Run the Micro XRCE-DDS Agent:

    ```bash
    MicroXRCEAgent udp4 -p 8888
    ```

This command starts the agent and listens on UDP port 8888, which is the default port for PX4 XRCE-DDS communication.

### Step 2: Launch PX4 SITL with Gazebo Fortress

Launch PX4 SITL with Gazebo:

```bash
cd ~/px4-Autopilot
make px4_sitl gazebo
```

### Step 3: Create a ROS 2 Package for UAV Waypoint Navigation

Create a new ROS 2 package to control the UAV using DDS-XRCE:

```bash
ros2 pkg create uav_waypoint_navigation --build-type ament_python --dependencies rclpy
```

### Step 4: Python Script for Waypoint Navigation (`uav_waypoint_navigation.py`)

Here's the Python script that sends waypoint commands to PX4 using DDS-XRCE instead of MAVROS:

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from px4_msgs.msg import VehicleCommand, TrajectorySetpoint, OffboardControlMode, Timesync

class UAVWaypointNavigator(Node):

    def __init__(self):
        super().__init__('uav_waypoint_navigator')

        # Create publishers
        self.command_pub = self.create_publisher(VehicleCommand, "/fmu/in/vehicle_command", 10)
        self.offboard_control_mode_pub = self.create_publisher(OffboardControlMode, "/fmu/in/offboard_control_mode", 10)
        self.trajectory_setpoint_pub = self.create_publisher(TrajectorySetpoint, "/fmu/in/trajectory_setpoint", 10)

        # Subscriber to sync time with PX4
        self.timesync_sub = self.create_subscription(Timesync, "/fmu/out/timesync", self.timesync_callback, 10)

        self.timestamp = 0  # Time synchronization with PX4

        # Start a timer to send control commands
        self.create_timer(0.1, self.control_loop)

    def timesync_callback(self, msg):
        # Update timestamp to sync with PX4
        self.timestamp = msg.timestamp

    def control_loop(self):
        # Send Offboard Control Mode
        offboard_mode = OffboardControlMode()
        offboard_mode.timestamp = self.timestamp
        offboard_mode.position = True
        offboard_mode.velocity = False
        offboard_mode.acceleration = False
        offboard_mode.attitude = False
        offboard_mode.body_rate = False
        self.offboard_control_mode_pub.publish(offboard_mode)

        # Send a Trajectory Setpoint (waypoint)
        waypoint = TrajectorySetpoint()
        waypoint.timestamp = self.timestamp
        waypoint.position = [0.0, 0.0, -5.0]  # Set desired x, y, z position (z is negative in NED frame)
        waypoint.yaw = 0.0  # Set desired yaw
        self.trajectory_setpoint_pub.publish(waypoint)

        # Arm and set to Offboard mode
        self.arm_vehicle()
        self.set_offboard_mode()

    def arm_vehicle(self):
        # Command to arm the vehicle
        self.publish_vehicle_command(VehicleCommand.VEHICLE_CMD_COMPONENT_ARM_DISARM, 1.0)

    def set_offboard_mode(self):
        # Command to switch to offboard mode
        self.publish_vehicle_command(VehicleCommand.VEHICLE_CMD_DO_SET_MODE, 1.0, 6.0)

    def publish_vehicle_command(self, command, param1=0.0, param2=0.0):
        # Publish a vehicle command
        msg = VehicleCommand()
        msg.timestamp = self.timestamp
        msg.param1 = param1
        msg.param2 = param2
        msg.command = command
        msg.target_system = 1
        msg.target_component = 1
        msg.source_system = 1
        msg.source_component = 1
        msg.from_external = True
        self.command_pub.publish(msg)
        self.get_logger().info(f"Published vehicle command: {command}")

def main(args=None):
    rclpy.init(args=args)
    navigator = UAVWaypointNavigator()
    rclpy.spin(navigator)
    navigator.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Key Components of the Script

1. **Time Synchronization**: Synchronizes time with PX4 using the `Timesync` message.
2. **Offboard Control Mode**: Sets the UAV into offboard control mode using the `OffboardControlMode` message.
3. **Waypoint Control**: Sends position commands using the `TrajectorySetpoint` message to guide the UAV to the desired waypoints.
4. **Vehicle Commands**: Arms the UAV and sets it into offboard mode using the `VehicleCommand` message.

### Step 5: Build and Run the Package

1. **Build the package**:

    ```bash
    cd ~/ros2_ws
    colcon build --packages-select uav_waypoint_navigation
    source install/setup.bash
    ```

2. **Run the script**:

    ```bash
    ros2 run uav_waypoint_navigation uav_waypoint_navigation.py
    ```

### Summary

This setup uses Micro XRCE-DDS Agent to interface directly with PX4 via the DDS-XRCE protocol, allowing you to send commands and waypoints without needing MAVROS. The provided ROS 2 node publishes control messages to set the UAV into offboard mode and guide it through specified waypoints. This approach is efficient for resource-constrained systems and leverages the native DDS-XRCE support in PX4, making it ideal for real-time UAV control scenarios.